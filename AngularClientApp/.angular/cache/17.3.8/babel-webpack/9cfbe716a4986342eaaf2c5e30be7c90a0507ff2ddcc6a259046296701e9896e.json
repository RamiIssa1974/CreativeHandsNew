{"ast":null,"code":"import { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { combineLatest, of, throwError } from 'rxjs';\nimport { shareReplay, tap, map, catchError } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nconst CACHE_SIZE = 1;\nexport let ProductsService = /*#__PURE__*/(() => {\n  class ProductsService {\n    getCategories() {\n      return this.categories$;\n    }\n    getCategoryById(categoryId) {\n      if (this.categories$) return this.categories$.pipe(map(categories => {\n        const category = categories.find(ct => ct.Id === categoryId);\n        return category ? category : {\n          Id: -1,\n          Name: '',\n          IsBelongToProduct: false\n        };\n      }));else return of({\n        Id: -1,\n        Name: '',\n        IsBelongToProduct: false\n      });\n    }\n    get getSavedProductId() {\n      return this.savedProductId;\n    }\n    constructor(http) {\n      this.http = http;\n      this.isUploadig = false;\n      this.savedProductId = 0;\n      this.getProductUrl = environment.baseApiUrl + \"api/products/GetProducts\";\n      this.getCategoriesUrl = environment.baseApiUrl + \"api/products/Categories\";\n      this.getImagesUrl = environment.baseApiUrl + \"api/products/Images\";\n      this.getProductVariationsUrl = environment.baseApiUrl + \"api/products/ProductVariations\";\n      this.getAvailableColoursUrl = environment.baseApiUrl + \"api/products/AvailableColours\";\n      this.getProductCategoriesUrl = environment.baseApiUrl + \"api/products/ProductCategories\";\n      this.saveProductUsrl = environment.baseApiUrl + \"api/products/Product\";\n      this.uploadFilesUrl = environment.baseApiUrl + \"Api/UploadFiles\";\n      this.dbProducts$ = this.getProductsFromDb().pipe(shareReplay(CACHE_SIZE));\n      this.categories$ = this.getCategoriesFromServer().pipe(shareReplay(CACHE_SIZE));\n      this.images$ = this.http.get(this.getImagesUrl).pipe(shareReplay(CACHE_SIZE), catchError(error => {\n        console.error('Error fetching product Images:', error);\n        return of([]); // Return an empty array if the data is not available\n      }));\n      this.productVariations$ = this.http.get(this.getProductVariationsUrl).pipe(shareReplay(CACHE_SIZE), catchError(error => {\n        console.error('Error fetching product variations:', error);\n        return of([]); // Return an empty array if the data is not available\n      }));\n      this.availableColours$ = this.http.get(this.getAvailableColoursUrl).pipe(shareReplay(CACHE_SIZE), catchError(error => {\n        console.error('Error fetching available colours:', error);\n        return of([]); // Return an empty array if the data is not available\n      }));\n      this.productCategory$ = this.http.get(this.getProductCategoriesUrl).pipe(shareReplay(CACHE_SIZE), catchError(error => {\n        console.error('Error fetching product variations:', error);\n        return of([]); // Return an empty array if the data is not available\n      }));\n      this.combined$ = combineLatest([this.dbProducts$, this.categories$, this.images$, this.availableColours$, this.productVariations$, this.productCategory$]);\n      this.products$ = this.combined$.pipe(map(([products, categories, images, colours, variations, productCats]) => {\n        console.log(\"Products from combined$: \", products); // Log products from combined$\n        return products.map(product => ({\n          ...product,\n          Categories: categories.filter(ct => productCats.some(pc => pc.ProductId === product.Id && pc.CategoryId === ct.Id)),\n          Images: images.filter(im => im.ProductId === product.Id).map(img => img.Id + \".\" + img.Extension.trim()),\n          ProductVariations: variations.filter(vr => vr.ProductId === product.Id),\n          AvailableColours: colours.filter(cl => cl.ProductId === product.Id).map(cl => cl.Code)\n        }));\n      }), tap(pr => {\n        console.log(\"Products after processing: \", pr); // Log processed products\n      }));\n      console.log(\"ProductsService Calling constructor\");\n    }\n    saveProductAndFiles(filesToUpload, prodctSaveData) {\n      if (filesToUpload.length > 0) {\n        this.isUploadig = true;\n        const fd = new FormData();\n        filesToUpload.forEach(fileToUpload => fd.append(\"files\", fileToUpload, fileToUpload.name));\n        fd.append(\"productId\", prodctSaveData.Id.toString());\n        return this.http.post(this.uploadFilesUrl, fd);\n      }\n      return of({\n        VideoId: -1,\n        ProductId: prodctSaveData.Id,\n        PurchaseId: -1,\n        UploadedImages: []\n      });\n    }\n    saveProduct(prodctSaveData) {\n      return this.http.post(this.saveProductUsrl, prodctSaveData).pipe(tap(res => {\n        if (res > 0) {\n          this.dbProducts$ = this.getProductsFromDb().pipe(shareReplay(CACHE_SIZE));\n        }\n      }));\n    }\n    getProducts(searchParam) {\n      console.log(\"getProducts => searchParam:\", searchParam);\n      return this.products$.pipe(map(products => {\n        console.log(\"Products before filtering:\", products);\n        return products.filter(pr => {\n          const idMatches = searchParam.Id < 0 || searchParam.Id === pr.Id;\n          const nameMatches = !searchParam.Name || pr.Name.includes(searchParam.Name);\n          const descriptionMatches = !searchParam.Description || pr.Description.includes(searchParam.Description);\n          const barcodeMatches = !searchParam.Barcode || pr.Barcode.includes(searchParam.Barcode);\n          const categoryMatches = searchParam.CategoryId < 0 || pr.Categories.some(cat => cat.Id === searchParam.CategoryId);\n          return idMatches && nameMatches && descriptionMatches && barcodeMatches && categoryMatches;\n        });\n      }), tap(filteredProducts => {\n        console.log(\"Filtered products:\", filteredProducts);\n      }));\n    }\n    //getProductsFromDb(search: IProductSearchRequest): Observable<IProduct[]> {\n    getProductsFromDb() {\n      let searchParam = {\n        Id: -1,\n        Barcode: \"\",\n        Description: \"\",\n        Name: \"\",\n        CategoryId: -1,\n        SubCategoryId: -1\n      };\n      let request = JSON.stringify(searchParam);\n      console.log(\"getProductsFromDb=>searchParam: \" + request);\n      let httpOptions = {\n        headers: new HttpHeaders({\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Headers': 'Content-Type',\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Methods': 'GET,POST,OPTIONS,DELETE,PUT'\n        })\n      };\n      return this.http.post(this.getProductUrl, request, httpOptions);\n    }\n    getCategoriesFromServer() {\n      return this.http.get(this.getCategoriesUrl).pipe();\n    }\n    handleError(err) {\n      // in a real world app, we may send the server to some remote logging infrastructure\n      // instead of just logging it to the console\n      let errorMessage = '';\n      if (err.error instanceof ErrorEvent) {\n        // A client-side or network error occurred. Handle it accordingly.\n        errorMessage = `An error occurred: ${err.error.message}`;\n      } else {\n        // The backend returned an unsuccessful response code.\n        // The response body may contain clues as to what went wrong,\n        errorMessage = `Server returned code: ${err.status}, error message is: ${err.message}`;\n      }\n      console.error(errorMessage);\n      return throwError(errorMessage);\n    }\n    static #_ = this.ɵfac = function ProductsService_Factory(t) {\n      return new (t || ProductsService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ProductsService,\n      factory: ProductsService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ProductsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}